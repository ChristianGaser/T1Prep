#!/usr/bin/env bash
#
# PURPOSE:
#   Resample left (und optional right) hemisphere surface data to a target sphere,
#   optionally smooth the values and write a single combined GIfTI using
#   CAT_SurfCurvature.
#
# USAGE:
#   SurfResample.sh [options] <lh_input_value_file> [<lh_input_value_file> ...]
#
# INPUT:
#   Left hemisphere value files (e.g. lh.thickness.gii or lh.thickness.dat).
#   The script auto-derives corresponding central/sphere files and the right
#   hemisphere counterparts by name.
#
# OUTPUT:
#   One combined .gii per left input file containing LH (+RH) resampled values.
# ______________________________________________________________________
#
# Christian Gaser
# Structural Brain Mapping Group (https://neuro-jena.github.io)
# Departments of Neurology and Psychiatry
# Jena University Hospital
# ______________________________________________________________________

# ----------------------------------------------------------------------
# global parameters
# ----------------------------------------------------------------------

# defaults
os_type=$(uname -s) # Determine OS type

script_dir=$(dirname "$0")
root_dir=$(dirname $script_dir)
name_file=${root_dir}/Names.tsv

source "${script_dir}/utils.sh"

time=$(date "+%Y%b%d_%H%M")
JOB_ID="jobrun_$(date +%s%N)"  # Unique ID based on timestamp in nanoseconds
PROGRESS_DIR="/tmp/progress_bars/$JOB_ID"

# Parameters
use_absolute=0
method=0
fwhm=0
removestr=''
noclobber=0
gifti=0

declare -a FILES=()
declare -a OUT_ARRAY=()

# ----------------------------------------------------------------------
# run main
# ----------------------------------------------------------------------

main()
{
  parse_args ${1+"$@"}
  get_OS
  
  process "$@"

  exit 0
}

# ----------------------------------------------------------------------
# check arguments and files
# ----------------------------------------------------------------------

parse_args()
{
  local optname optarg
  
  if [ $# -lt 1 ]; then
    help
    exit 1
  fi

  count=0
  while [ $# -gt 0 ]; do
    optname="${1%%=*}"
    optarg="${2:-}"

    case "$1" in
    --a* | -a*)
      use_absolute=1
      ;;
    --r* | -r*)
      exit_if_empty "$optname" "$optarg"
      removestr=$optarg
      ;;
    --f* | -f*)
      optarg=`echo $optarg | sed 's,[^0-9],,g'`
      exit_if_empty "$optname" "$optarg"
      fwhm=$optarg
      ;;
    --n* | -n*)
      noclobber=1
      ;;
    --gifti | -gifti)
      gifti=1
      ;;
    --mc | -mc)
      method=0
      ;;
    --gc* | -gc*)
      method=1
      ;;
    --c* | -c*)
      method=2
      ;;
    --si | -si)
      method=3
      ;;
    --mc0 | -mc0)
      method=4
      ;;
    --bi | -bi)
      method=5
      ;;
    --sh | -sh)
      method=6
      ;;
    --fi | -fi)
      method=7
      ;;
    --min-curv | -min-curv)
      method=8
      ;;
    --max-curv | -max-curv)
      method=9
      ;;
    --sd | -sd)
      method=10
      ;;
    --dp | -dp)
      optarg=`echo $optarg | sed 's,[^0-9],,g'`
      exit_if_empty "$optname" "$optarg"
      method=$optarg
      ;;
      -h | --help | --h | -v | --version | -V)
        help
        exit 1
        ;;
      -*)
        echo "basename $0: ERROR: Unrecognized option \"$1\"" >&2
        exit 1
        ;;
      *)
        if [ ! -f "$1" ]; then
          if [ ! -L "$1" ]; then
            echo "${RED}File $1 was not found and will be skipped.${NC}" >&2
          fi
        else
          FILES[$count]=$1
          ((count++))
        fi
        ;;
    esac
    shift
  done

}

# ----------------------------------------------------------------------
# per-file processing
# ----------------------------------------------------------------------
process_file() {
  local infile="$1"

  local dname bname hemi measure out_name
  dname=$(dirname "$infile")
  bname=$(basename "$infile")

  # only lh.* supported for now
  if [[ "$bname" == lh.* ]]; then
    measure=${bname#*.}; measure=${measure%%.*}
    sphere_reg=".sphere.reg"
    rh_bname="${bname/lh./rh.}"
    # default output naming
    if [[ -n "${out}" ]]; then
      out_name="${out}/${bname/lh./s${fwhm}.mesh.}.${ext}"
    else
      out_name="${dname}/${bname/lh./s${fwhm}.mesh.}.${ext}"
    fi
    out_name="${out_name/.$measure/.${measure}.resampled_32k}"
  elif [[ "$bname" == *_left* ]]; then
    echo -e "${RED}BIDS format not yet implemented (${bname}).${NC}" >&2
    return 1
  else
    echo -e "${RED}File '$infile' should be left hemisphere data (lh.*).${NC}" >&2
    return 1
  fi

  OUT_ARRAY+=("$out_name")
}


# ----------------------------------------------------------------------
# process data
# ----------------------------------------------------------------------

process()
{  
  n="${#FILES[@]}"
  
  for f in "${FILES[@]}"; do
    if [[ ! -f "$f" && ! -L "$f" ]]; then
      echo -e "${RED}File '$f' not found – skipping.${NC}" >&2
      continue
    fi
    process_file "$f"
  done
 
  # serial
  if [  ${n} -gt 1 ]; then
    mkdir -p "$PROGRESS_DIR"
    rm -f "$PROGRESS_DIR"/*.progress
    ${script_dir}/progress_bar_multi.sh 1 "$PROGRESS_DIR" 40 2 "CAT_SurfCurvature" &
    progress_pid=$!

    # Trap signals: Ctrl+C (INT), termination (TERM), or exit (EXIT)
    trap cleanup INT TERM
  fi 
   
  j=1
  for ((i=0; i<${n}; i++)); do
    if [  ${n} -gt 1 ]; then
      echo "$j/$n" > "$PROGRESS_DIR/job0.progress"
      ((j++))
      echo 0 > "$PROGRESS_DIR/job0.status"
    fi
    
    "${bin_dir}/CAT_SurfCurvature" \
      -fwhm "${fwhm}" \
      -out  "${OUT_ARRAY[$i]}" \
      -unit "${LH_ARRAY[$i]}" \
      -unit "${RH_ARRAY[$i]}" 2>&1
      
    exit_code=$?
    pids=($!)

    if [[ ${n} -gt 1  &&  $exit_code -ne 0 ]]; then
      echo 1 > "$PROGRESS_DIR/job0.status"
    fi
  done
  
  if [  ${n} -gt 1 ]; then
    wait $progress_pid
    rm -r "$PROGRESS_DIR"
  fi
  exit $?
}


# ----------------------------------------------------------------------
# help
# ----------------------------------------------------------------------

help() {
cat << EOM
${BOLD}${BLUE}$0
---------------------------------------------${NC}

${BOLD}USAGE:${NC}
  ${GREEN}$0 [options] <filename(s)>${NC}

${BOLD}DESCRIPTION:${NC}
Resample left (and optional right) hemisphere surfaces/values to target spheres and
write a single combined GIfTI per subject using CAT_SurfCurvature.

${BOLD}OPTIONS:${NC}
  --out <DIR>                  Output directory (default: same as input file dir)
  --ext <STR>                  Output file extension (default: $ext)
  --trg-sphere <FILE>          Target sphere for the left hemisphere
  --fwhm <FLOAT>               Smoothing FWHM applied inside CAT_SurfCurvature (default: $fwhm)
  -h | --help                  Show this help and exit

${BOLD}INPUT NAMING EXPECTATIONS:${NC}
  lh.* case (supported now)
    lh.<measure>.something.gii
    Will look for:
      lh.central.gii               (same base, measure replaced by "central")
      lh.sphere.reg.gii            (same base, measure replaced by "sphere.reg")
      rh.<measure>.something.gii   (right hemisphere counterpart)
      rh.central.gii, rh.sphere.reg.gii accordingly

  *_left* (BIDS) not yet implemented → the script exits with an error.
        
${BOLD}OUTPUT:${NC}
  For each LH input file, writes a combined GIfTI (LH+RH) with resampled (and optionally smoothed) values. If extension is "dat" used, then an external binary file is saved, which is the default
  for use with SPM.

${BOLD}Dependencies:${NC}
  CAT_SurfCurvature
  ${script_dir}/progress_bar_multi.sh
  ${script_dir}/parallelize

${BOLD}Author:${NC}
  Christian Gaser (christian.gaser@uni-jena.de)

EOM

}

# ----------------------------------------------------------------------
# call main program
# ----------------------------------------------------------------------

main "${@}"