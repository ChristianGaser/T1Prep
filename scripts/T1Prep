#! /bin/bash
#
# PURPOSE: This script performs preprocessing steps on T1-weighted MRI images
#          to create segmentations and extract cortical surface. 
#
# USAGE: T1Prep [options] file1.nii file2.nii ...
#
# INPUT: T1-weighted MRI images in NIfTI format (.nii or .nii.gz).
#
# OUTPUT: Processed images and segmentation results in the specified output directory.
#
# FUNCTIONS: 
# - main: The main function that executes the preprocessing steps.
# - parse_args: Parses the command line arguments.
# - exit_if_empty: Checks if a command line argument is empty and exits with an error message if it is.
# - check_python_cmd: Checks if the Python command is available.
# - check_files: Checks if the input files exist.
# - check_python: Checks if the specified Python command is available.
# - check_python_module: Checks for python modules.
# - check_python_libraries: Checks for python libraries.
# - get_OS: Identifies operations system and folder of binaries.
# - bar: Displays progress bar.
# - get_no_of_cpus: Determines the number of available CPUs.
# - process: Performs the preprocessing steps on each input file.

########################################################
# global parameters
########################################################

# Text formatting
BOLD=$(tput bold)
UNDERLINE=$(tput smul)
NC=$(tput sgr0) # Reset all attributes

# Colors
BLACK=$(tput setaf 0)
RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
YELLOW=$(tput setaf 3)
BLUE=$(tput setaf 4)
PINK=$(tput setaf 5)
CYAN=$(tput setaf 6)
WHITE=$(tput setaf 7)

# defaults
T1prep_dir=$(dirname $(dirname "$0"))
surf_templates_dir=${T1prep_dir}/templates_surfaces_32k
T1prep_env=${T1prep_dir}/T1Prep-env
os_type=$(uname -s) # Determine OS type
outsurfdir=''
outmridir=''
correct_thickness=1
use_bids_naming=0
thickness_fwhm=6
median_filter=2
save_hemi=0
save_surf=1
save_csf=0
save_mwp=1
save_wp=0
save_rp=0
save_p=0
estimate_pial_white=0
estimate_spherereg=1
estimate_seg=1
downsample=0.0
vessel=0.5
sharpening=0.02
post_fwhm=1.5
pre_fwhm=2
re_install=0
use_sanlm=0
use_amap=0
isoval=0.5
thresh=0.5
debug=0
multi=0

########################################################
# run main
########################################################

main ()
{
  check_python_cmd  
  parse_args ${1+"$@"}
  if [[ "$multi" -ne -2 ]]; then
    logo
    check_python
    check_python_module venv
    check_python_module pip
    check_python_libraries    
  fi

  check_files
  get_OS
  
  process "$@"

  exit 0
}


########################################################
# check arguments and files
########################################################

parse_args ()
{
  cmd_dir=$(dirname "$0")
  local optname optarg

  if [ $# -lt 1 ]; then
    logo
    help
    exit 1
  fi

  while [ $# -gt 0 ]; do
    optname="${1%%=*}"
    optarg="${2:-}"

    case "$1" in
      --re-install)
        re_install=1
        ;;
      --python)
        exit_if_empty "$optname" "$optarg"
        python=$optarg
        shift
        ;;
      --out-dir | --outdir)
        exit_if_empty "$optname" "$optarg"
        outdir=$optarg
        shift
        ;;
      --pre-fwhm)
        exit_if_empty "$optname" "$optarg"
        pre_fwhm=$optarg
        shift
        ;;
      --post-fwhm)
        exit_if_empty "$optname" "$optarg"
        post_fwhm=$optarg
        shift
        ;;
      --thickness-fwhm)
        exit_if_empty "$optname" "$optarg"
        thickness_fwhm=$optarg
        shift
        ;;
      --downsample)
        exit_if_empty "$optname" "$optarg"
        downsample=$optarg
        shift
        ;;
      --sharpen)
        exit_if_empty "$optname" "$optarg"
        sharpening=$optarg
        shift
        ;;
      --median-filter)
        exit_if_empty "$optname" "$optarg"
        median_filter=$optarg
        shift
        ;;
      --thresh*)
        exit_if_empty "$optname" "$optarg"
        thresh=$optarg
        shift
        ;;
      --vessel*)
        exit_if_empty "$optname" "$optarg"
        vessel=$optarg
        shift
        ;;
      --bin-dir| --bindir)
        exit_if_empty "$optname" "$optarg"
        bin_dir=$optarg
        shift
        ;;
      --no-overwrite*)
        exit_if_empty "$optname" "$optarg"
        no_overwrite=$optarg
        shift
        ;;
      --multi*)
        exit_if_empty "$optname" "$optarg"
        multi=$optarg
        shift
        ;;
      --hemi*)
        save_hemi=1
        ;;
      --no-surf)
        save_surf=0
        ;;
      --no-seg*)
        estimate_seg=0
        ;;
      --no-sphere*)
        estimate_spherereg=0
        ;;
      --no-mwp*)
        save_mwp=0
        ;;
      --wp*)
        save_wp=1
        ;;
      --rp*)
        save_rp=1
        ;;
      --p*)
        save_p=1
        ;;
      --csf*)
        save_csf=1
        ;;
      --amap)
        use_amap=1
        use_sanlm=1
        ;;
      --bids)
        use_bids_naming=1
        ;;
      --no-thickness-correct)
        correct_thickness=0
        ;;
      --pial-white)
        estimate_pial_white=1
        ;;
      --debug)
        debug=1
        ;;
      -h | --help | -v | --version | -V)
        help
        exit 1
        ;;
      -*)
        echo "`basename $0`: ERROR: Unrecognized option \"$1\"" >&2
        ;;
      *)
        ARRAY[$count]=$1
        ((count++))
        ;;
    esac
    shift
  done

  if [[ "$estimate_seg" -eq 0 && "$save_surf" -eq 0 ]]; then
    echo "${RED}ERROR: Options "--no-surf" and "--no-seg" cannot be used together.${NC}" >&2
    exit 1
  fi

}

########################################################
# check arguments
########################################################

exit_if_empty ()
{
  local desc val

  desc="$1"
  shift
  val="$*"

  if [ -z "$val" ]; then
    echo "${RED}ERROR: No argument given with \"$desc\" command line argument!${NC}" >&2
    exit 1
  fi
}

########################################################
# logo
########################################################

logo ()
{
echo $BLUE
cat <<__EOM__

████████╗ ██╗ ██████╗ ██████╗ ███████╗██████╗
╚══██╔══╝███║ ██╔══██╗██╔══██╗██╔════╝██╔══██╗
   ██║    ██║ █████╔╝║██████╔╝█████╗  ██████╔╝
   ██║    ██║ ██╔═══╝ ██╔══██╗██╔══╝  ██╔═══╝ 
   ██║    ██║ ██║     ██║  ██║███████╗██║   
   ╚═╝    ╚═╝ ╚═╝     ╚═╝  ╚═ ╚══════╝╚═╝   

__EOM__
echo $NC
}

########################################################
# check for python version
########################################################

check_python_cmd ()
{
  if command -v python3 &>/dev/null; then
    python="python3"
  elif command -v python &>/dev/null; then
    python="python"
  else
    echo "${RED}python or python3 not found. Please use '--python' flag to define Python command and/or install Python${NC}" >&2
    exit 1
  fi
}

########################################################
# check files
########################################################

check_files ()
{
  SIZE_OF_ARRAY="${#ARRAY[@]}"
  if [ "$SIZE_OF_ARRAY" -eq 0 ]; then
    echo "${RED}ERROR: No files given!${NC}" >&2
    help
    exit 1
  fi

  i=0
  while [ "$i" -lt "$SIZE_OF_ARRAY" ]; do
    if [ ! -f "${ARRAY[$i]}" ]; then
      if [ ! -L "${ARRAY[$i]}" ]; then
        echo "${RED}ERROR: File ${ARRAY[$i]} not found${NC}" >&2
        help
        exit 1
      fi
    else
      if [[ ! "${ARRAY[$i]}" =~ \.nii(\.gz)?$ ]]; then
        echo "${RED}ERROR: File ${ARRAY[$i]} is not a valid NIfTI file${NC}" >&2
        help
        exit 1
      fi
    fi
    ((i++))
  done

}

########################################################
# check for python
########################################################

check_python ()
{
  if ! command -v "${python}" &>/dev/null; then
    echo "${RED}ERROR: $python not found${NC}" >&2
    exit 1
  fi
}

########################################################
# check for python modules (e.g. pip)
########################################################

# Function to check if a Python module is available
check_python_module() {
    ${python} -c "import $1" 2>/dev/null
    if [ $? -ne 0 ]; then
        echo "Error: Python module '$1' is not installed."
        echo "On Linux use 'apt install $(basename "$python")-"$1"'"
        exit 1
    fi
}

########################################################
# check for python libraries
########################################################

check_python_libraries ()
{
  # Remove T1pre-env if reinstallation is selected
  if [[ -d "${T1prep_env}" && "${re_install}" == "1" ]]; then
    rm -r "${T1prep_env}"
  fi

  if [ -d ${T1prep_env} ]; then
    $python -m venv ${T1prep_env}
    source ${T1prep_env}/bin/activate
    
    $python -c "import deepmriprep" &>/dev/null
    if [ $? -gt 0 ]; then
      install_deepmriprep
    fi
  else
    install_deepmriprep
  fi      
}

########################################################
# install deepmriprep
########################################################

install_deepmriprep ()
{
  echo "Install deepmriprep"
  $python -m venv ${T1prep_env}
  source ${T1prep_env}/bin/activate
  $python -m pip install -U pip
  $python -m pip install scipy>=1.10.1 torch>=1.11.0 deepbet>=1.0.2 torchreg>=0.1.2 requests SplineSmooth3D>=0.1.1 nxbc>=0.2.0 deepmriprep>=0.1.0
  
  $python -c "import deepmriprep" &>/dev/null
  if [ $? -gt 0 ]; then
    echo "${RED}ERROR: Installation of deepmriprep not successful. 
      Please install it manually${NC}" >&2
    exit 1
  fi
  
  # Allow executable on MacOS
  case "$os_type" in
    Darwin*)  
      find MacOS -name "${bin_dir}/CAT*" -exec xattr -d com.apple.quarantine {} \;
      ;;
  esac
}

########################################################
# get OS
########################################################

get_OS () 
{
  # Determine CPU architecture
  cpu_arch=$(uname -m)

  case "$os_type" in
    Linux*)   
      bin_dir="${T1prep_dir}/Linux"
      ;;
    Darwin*)  
      if [[ "$cpu_arch" == arm64 ]]; then 
        bin_dir="${T1prep_dir}/MacOS"
      else 
        echo "MacOS Intel not supported anymore"
        exit 1
      fi
      ;;
    CYGWIN*|MINGW32*|MSYS*|MINGW*) 
      bin_dir="${T1prep_dir}/Windows"
      ;;
    *)
      echo "Unknown OS system"
      exit 1
      ;;
  esac
  
}

########################################################
# progress bar
########################################################
bar() 
{
  # Usage: bar 1 100 Name
  #      ^--------- Elapsed Percentage (0-100).
  #       ^------ Total length in chars.
  #         ^-- Name of process.
  ((it=$1*100/$2))
  ((elapsed=$1))

  # Create the bar with spaces.
  printf -v prog  "%${elapsed}s"
  printf -v total "%$(($2-elapsed))s"

  # Pad the name to 50 characters (using printf)
  printf -v padded_name "%-10s%-30s" "$3" " "

  #printf '%s %s\r' "${prog// /■}${total} ${it}%" "${3}"
  printf '%s %s\r' "${prog// /■}${total} ${elapsed}/${2}" "${padded_name}"
  
  # if end is reached print extra line
  if [ "${1}" -eq "${2}" ]; then
    printf -v padded_name "%-100s" " "
    printf '%s\r' "${padded_name}"
  fi
}

########################################################
# surface estimation
########################################################
surface_estimation() 
{  
  side=$1
  outmridir=$2
  outsurfdir=$3
  estimate_spherereg=$4

  # create dynamic variables
  pbt=pbt_$side
  thick=thick_$side
  hemi=hemi_$side
  ppm=ppm_$side
  gmt=gmt_$side
  mid=mid_$side
  pial=pial_$side
  wm=wm_$side
  sphere=sphere_$side
  spherereg=spherereg_$side
  intensity=intensity_$side
  intensity_pial=intensity_pial_$side
  intensity_white=intensity_white_$side
  fshemi="${side/left/lh}"
  fshemi="${fshemi/right/rh}"
  Fsavg=${surf_templates_dir}/${fshemi}.central.freesurfer.gii
  Fsavgsphere=${surf_templates_dir}/${fshemi}.sphere.freesurfer.gii
  
  # Change number of commands if spherical registration is disabled
  if [ "${estimate_spherereg}" -eq 1 ]; then
    ((end_count=10))
  else
    ((end_count=6))
  fi

  # Define label image for thickness correction
  if [ "${correct_thickness}" -eq 1 ]; then
    label_str=" -label ${outmridir}/${!hemi} "
  else
    label_str=""
  fi
    
  if [ "${debug}" -eq 0 ]; then
    verbose=""
  else 
    verbose=" -verbose "
  fi

  # This section of the script checks if a specific hemisphere file exists within a given directory.
  if [ -f "${outmridir}/${!hemi}" ]; then
  
    # Progress indication
    bar 2 $end_count "Calculate $side thickness"
  
    # Executes the 'CAT_VolThicknessPbt' tool with various options:
    # - ${verbose} toggles verbose output.
    # - '-n-avgs 4' sets the number of averages for distance estimation.
    # - '-min-thickness' sets a minimum thickness threshold.
    # - '-fwhm' sets the FWHM for thickness smoothing.
    #${bin_dir}/CAT_VolThicknessPbt ${verbose} -median-filter ${median_filter} -sharpen ${sharpening} -downsample ${downsample} -n-avgs 8 -fwhm ${thickness_fwhm} ${outmridir}/${!hemi} ${outmridir}/${!gmt} ${outmridir}/${!ppm}
  
    # Updates progress to 'Extract $side surface'.
    bar 4 $end_count "Extract $side surface"
  
    # Executes the 'CAT_VolMarchingCubes' tool to generate a surface mesh from volumetric data:
    # - '-median-filter' applies a median filter a specified number of times to reduce artifacts.
    # - '-pre-fwhm' and '-post-fwhm' control pre and post smoothing.
    # - '-thresh' sets the isovalue for mesh generation.
    # - '-no-distopen' disables distance-based opening, a form of morphological operation.
    # - '-local-smoothing' applies additional local smoothing to the mesh.
    #${bin_dir}/CAT_VolMarchingCubes ${verbose} -median-filter ${median_filter} -pre-fwhm ${pre_fwhm} -post-fwhm ${post_fwhm} -thresh ${thresh} -scl-opening 0.9 -local-smoothing 10 ${outmridir}/${!ppm} ${outsurfdir}/${!mid}
  
    # Updates progress to 'Map $side thickness values'.
    bar 6 $end_count "Map $side thickness values"
  
    # Executes 'CAT_3dVol2Surf' to map volumetric data to a surface representation.
    # It uses a weighted average approach for mapping, ranging from -0.4..0.4 of the relative thickness using 5 steps
    ${bin_dir}/CAT_3dVol2Surf -weighted_avg -start -0.4 -steps 5 -end 0.4 ${outsurfdir}/${!mid} ${outmridir}/${!gmt} ${outsurfdir}/${!pbt}
  
    # Executes 'CAT_SurfDistance' to correct and map thickness values from a volumetric dataset to a surface.
    # It uses the mean of the closest distance between both surfaces and vice versa (Tfs from Freesurfer).
    #${bin_dir}/CAT_SurfDistance -mean ${label_str} -thickness ${outsurfdir}/${!pbt} ${outsurfdir}/${!mid} ${outsurfdir}/${!thick}

    # Estimate the necessary shift if the threshold is not 0.5
    shift=$(echo "$thresh - $isoval" | bc)
    if (( $(echo "$shift != 0" | bc) )); then
      ${bin_dir}/CAT_Central2Pial ${outsurfdir}/${!mid} ${outsurfdir}/${!pbt} ${outsurfdir}/${!mid} ${shift}
    fi

    # Executes 'CAT_Central2Pial' twice to estimate both pial and white matter surfaces.
    if [ "${estimate_pial_white}" -eq 1 ]; then
      ${bin_dir}/CAT_Central2Pial -check_intersect -label ${outmridir}/${!hemi} ${outsurfdir}/${!mid} ${outsurfdir}/${!thick} ${outsurfdir}/${!pial} 0.55
      ${bin_dir}/CAT_Central2Pial -check_intersect -label ${outmridir}/${!hemi} ${outsurfdir}/${!mid} ${outsurfdir}/${!thick} ${outsurfdir}/${!wm}  -0.55
      
      # Map intensity values of bias-corrected image from central, pial, and white surface for debugging
      if [[ "${debug}" -eq 1 && -f ${outmridir}/${mT1} ]]; then
        ${bin_dir}/CAT_3dVol2Surf -start 0 -steps 1 -end 0 ${outsurfdir}/${!mid} ${outmridir}/${mT1} ${outsurfdir}/${!intensity}
        ${bin_dir}/CAT_3dVol2Surf -start 0 -steps 1 -end 0 ${outsurfdir}/${!pial} ${outmridir}/${mT1} ${outsurfdir}/${!intensity_pial}
        ${bin_dir}/CAT_3dVol2Surf -start 0 -steps 1 -end 0 ${outsurfdir}/${!wm} ${outmridir}/${mT1} ${outsurfdir}/${!intensity_white}
      fi
    fi
  
    # If estimate_spherereg is enabled, additional steps for spherical inflation and estimate_spherereg are performed.
    if [ "${estimate_spherereg}" -eq 1 ]; then
      # Updates progress to 'Spherical inflation $side hemisphere'.
      bar 8 $end_count "Spherical inflation $side hemisphere"
      # Inflates the surface to a sphere with additional areal smoothing.
      #${bin_dir}/CAT_Surf2Sphere ${outsurfdir}/${!mid} ${outsurfdir}/${!sphere} 6
  
      # Updates progress to 'Spherical estimate_spherereg $side hemisphere'.
      bar 10 $end_count "Spherical estimate_spherereg $side hemisphere"
      # Warps the surface to align with a standard sphere template, using specific mapping steps and averaging options.
      ${bin_dir}/CAT_WarpSurf ${verbose} -steps 2 -avg -i ${outsurfdir}/${!mid} -is ${outsurfdir}/${!sphere} -t ${Fsavg} -ts ${Fsavgsphere} -ws ${outsurfdir}/${!spherereg}
    fi
  else
    if [ "${estimate_seg}" -eq 0 ]; then    
      echo "${RED}ERROR: Could not find ${outmridir}/${!hemi}. Please run T1Prep with the '--hemisphere' flag first.${NC}" >&2
    else
      echo "${RED}ERROR: ${python} ${cmd_dir}/segment.py failed (file ${outmridir}/${!hemi} not found)${NC}" >&2
    fi
  fi
}

########################################################
# filter arguments so that filenames are removed 
########################################################

filter_arguments() {
  local args=("$@")   # All input arguments to filter
  local filtered=()   # Array to store filtered arguments
  local filepatterns=("${ARRAY[@]}")  # File patterns to exclude

  for arg in "${args[@]}"; do
    # Check if the argument is a file pattern by comparing it to ${ARRAY[@]}
    local is_filepattern=0
    for pattern in "${filepatterns[@]}"; do
      if [[ "$arg" == "$pattern" ]]; then
        is_filepattern=1
        break
      fi
    done

    # If it's not a file pattern, add it to the filtered list
    if [[ $is_filepattern -eq 0 ]]; then
      filtered+=("$arg")
    fi
  done

  echo "${filtered[@]}"  # Return the filtered arguments
}

########################################################
# process data
########################################################

process ()
{

  SIZE_OF_ARRAY="${#ARRAY[@]}"
  if [[ "$SIZE_OF_ARRAY" -lt 2 && "$multi" -ne -2 ]]; then
    multi=0
  fi

  # Call T1Prep script recursively with different "--multi" arguments in case that
  # "--multi" is defined
  if [[ "$multi" -ne 0 && "$multi" -gt -2 ]]; then

    # Filter arguments before recursion
    filtered_args=($(filter_arguments "$@")) # Use an array to handle filtered arguments

    # Call parallelize with filtered arguments and use memory limit of 24GB per process
    echo "${BOLD}Volume Segmentation${NC}"
    cmd=(
      "$(dirname "$0")/parallelize"
      -l "/tmp"
      -m 24
      -c "$(printf '"%q "' "$0" ${filtered_args[@]} --no-surf --hemisphere --multi -2)"
      "${ARRAY[@]}"
    )
    
    # Execute the command using eval
    if [ "${estimate_seg}" -eq 1 ]; then
      eval "${cmd[@]}"
    fi

    # Call parallelize with filtered arguments
    echo "${BOLD}Surface Estimation${NC}"
    # Define number of processes, otherwise estimate it automatically 
    if [ "$multi" -gt 0 ]; then
      arg_parallelize="-p ${multi}"
    fi
    cmd=(
      "$(dirname "$0")/parallelize"
      -l "/tmp"
      "${arg_parallelize}"
      -c "$(printf '"%q "' "$0" ${filtered_args[@]} --no-seg --multi -2)"
      "${ARRAY[@]}"
    )
    
    # Execute the command using eval
    if [ "${save_surf}" -eq 1 ]; then
      eval "${cmd[@]}"
    fi
    
    exit 1
  fi

  # Don't use colored text in parallelization (for clearer log-file)
  if [[ "$multi" -eq -2 ]]; then
    UNDERLINE=""
    BOLD=""
    NC=""
    CYAN=""
    PINK=""
    RED=""
    YELLOW=""
    BLUE=""
    WHITE=""
    GREEN=""
    BLACK=""
  fi
  
  ((i=0))
  ((j=0))
  while [ "$i" -lt "$SIZE_OF_ARRAY" ]; do

    # check whether absolute or relative names were given
    if [ ! -f "${ARRAY[$i]}" ]; then
      if [ -f "${pwd}/${ARRAY[$i]}" ]; then
        FILE="${pwd}/${ARRAY[$i]}"
      fi
    else
      FILE="${ARRAY[$i]}"
    fi

    # replace white spaces
    FILE="${FILE// /\\ }"

    # check whether processed files exist if no-overwrite flag is used
    if [ -n "${no_overwrite}" ]; then
      dname=$(dirname "$FILE")
      bname=$(basename "$FILE")
      bname="${bname%.nii.gz}"
      bname="${bname%.nii}"

      if [ -z "$outdir" ]; then
        outdir0=${dname}
      else
        outdir0=${outdir}
      fi
      processed=$(ls "${outdir0}/${no_overwrite}${bname}"* 2>/dev/null)
    fi

    if [ -z "${processed}" ]; then
      ARRAY2[$j]="$FILE"
      ((j++))
    else
      echo Skip processing of ${FILE}
    fi
    ((i++))
  done

  ((i=0))
  SIZE_OF_ARRAY="${#ARRAY2[@]}"
  
  # Exit if no files could be found for processing
  if [ "$SIZE_OF_ARRAY" -eq 0 ]; then
    exit 0
  fi

  # set overall starting time
  start0=$(date +%s)

  # use defined environment
  source ${T1prep_env}/bin/activate
  python="${T1prep_env}/bin/python"

  while [ "$i" -lt "$SIZE_OF_ARRAY" ]; do
    
    # set starting time
    start=$(date +%s)

    FILE="${ARRAY2[$i]}"

    # get directory and basename
    dname=$(dirname "$FILE")
    bname=$(basename "$FILE")
    bname="${bname%.nii.gz}"
    bname="${bname%.nii}"
    
    # if defined use output dir otherwise use the folder of input files
    if [ -z "$outdir" ]; then
      outdir0=${dname}
    else
      outdir0=${outdir}
    fi

    # check again whether processed files exist if no-overwrite flag is used
    if [ -n "${no_overwrite}" ]; then
      processed=$(ls "${outdir0}/${no_overwrite}${bname}"* 2>/dev/null)
      
      # Check if $processed is empty
      if [ -n "$processed" ]; then
        echo Skip processing of ${FILE}
        break  # Skip to the next iteration of the loop
      fi
    fi
    
    # create outdir if not exists
    if [ ! -d "$outdir0" ]; then
      mkdir -p "$outdir0"
    fi

    # get output names
    sanlm="${bname}_desc-sanlm.nii"
    seg="${bname}_seg.nii"
    p0="p0${bname}.nii"
    mT1="m${bname}.nii"

    hemi_left="${bname}_seg_hemi-L.nii"
    hemi_right="${bname}_seg_hemi-R.nii"
    gmt_left="${bname}_hemi-L_thickness.nii"
    gmt_right="${bname}_hemi-R_thickness.nii"

    # for the following filenames we have to remove the potential .gz from name
    ppm_left="${bname}_hemi-L_ppm.nii"
    ppm_right="${bname}_hemi-R_ppm.nii"

    if [ "${use_bids_naming}" -eq 1 ]; then

      echo "${RED}BIDS names for volumes not yet supported.${NC}"

      ppm_left="${bname}_hemi-L_ppm.nii"
      ppm_right="${bname}_hemi-R_ppm.nii"
      mid_left="${bname}_hemi-L_midthickness.surf.gii"
      mid_right="${bname}_hemi-R_midthickness.surf.gii"
      pial_left="${bname}_hemi-L_pial.surf.gii"
      pial_right="${bname}_hemi-R_pial.surf.gii"
      wm_left="${bname}_hemi-L_wm.surf.gii"
      wm_right="${bname}_hemi-R_wm.surf.gii"
      thick_left="${bname}_hemi-L_thickness.txt"
      thick_right="${bname}_hemi-R_thickness.txt"
      pbt_left="${bname}_hemi-L_pbt.txt"
      pbt_right="${bname}_hemi-R_pbt.txt"
      sphere_left="${bname}_hemi-L_sphere.surf.gii"
      sphere_right="${bname}_hemi-R_sphere.surf.gii"
      spherereg_left="${bname}_hemi-L_sphere.reg.surf.gii"
      spherereg_right="${bname}_hemi-R_sphere.reg.surf.gii"
      intensity_left="${bname}_hemi-L_intensity.txt"
      intensity_right="${bname}_hemi-R_intensity.txt"
      intensity_pial_left="${bname}_hemi-L_intensity_pial.txt"
      intensity_pial_right="${bname}_hemi-R_intensity_pial.txt"
      intensity_white_left="${bname}_hemi-L_intensity_white.txt"
      intensity_white_right="${bname}_hemi-R_intensity_white.txt"

      outmridir=${outdir0}
      outsurfdir=${outdir0}
    else      
      mid_left="lh.central.${bname}.gii"
      mid_right="rh.central.${bname}.gii"
      pial_left="lh.pial.${bname}.gii"
      pial_right="rh.pial.${bname}.gii"
      wm_left="lh.white.${bname}.gii"
      wm_right="rh.white.${bname}.gii"
      thick_left="lh.thickness.${bname}"
      thick_right="rh.thickness.${bname}"
      pbt_left="lh.pbt.${bname}"
      pbt_right="rh.pbt.${bname}"
      sphere_left="lh.sphere.${bname}.gii"
      sphere_right="rh.sphere.${bname}.gii"
      spherereg_left="lh.sphere.reg.${bname}.gii"
      spherereg_right="rh.sphere.reg.${bname}.gii"
      intensity_left="lh.intensity_${bname}.txt"
      intensity_right="rh.intensity_${bname}.txt"
      intensity_pial_left="lh.intensity_pial_${bname}.txt"
      intensity_pial_right="rh.intensity_pial_${bname}.txt"
      intensity_white_left="lh.intensity_white_${bname}.txt"
      intensity_white_right="rh.intensity_white_${bname}.txt"

      outmridir=${outdir0}/mri
      outsurfdir=${outdir0}/surf
    fi
        
    # create output folders if needed
    if [ ! -d "$outmridir" ]; then
      mkdir -p "$outmridir"
    fi
    if [ ! -d "$outsurfdir" ]; then
      mkdir -p "$outsurfdir"
    fi

    # print progress and filename
    j=$(expr $i + 1)
    echo "${BOLD}-------------------------------------------------------${NC}"
    if [ "${SIZE_OF_ARRAY}" -gt 1 ]; then
      echo "${GREEN}${j}/${SIZE_OF_ARRAY} ${BOLD}Processing ${FILE}${NC}"
    else
      echo "${BOLD}Processing ${FILE}${NC}"
    fi

    # 1. Call SANLM denoising filter
    # ----------------------------------------------------------------------
    if [ "${use_sanlm}" -eq 1 ]; then
      #echo "${BLUE}---------------------------------------------${NC}"
      #echo "${BLUE}SANLM denoising${NC}"
      ${bin_dir}/CAT_VolSanlm "${FILE}" "${outmridir}/${sanlm}"
      input="${outmridir}/${sanlm}"
    else
      input="${FILE}"
    fi
    
    # 2. Call deepmriprep segmentation 
    # ----------------------------------------------------------------------
    # check for outputs from previous step
    if [ -f "${input}" ]; then

      # Initialize command string with the Python script call

      cmd="${python} ${cmd_dir}/segment.py"
      
      # Append options conditionally
      [ "${use_amap}" -eq 1 ] && cmd+=" --amap --amapdir ${bin_dir}"
      [ "${save_mwp}" -eq 1 ] && cmd+=" --mwp"
      [ "${save_wp}" -eq 1 ] && cmd+=" --wp"
      [ "${save_rp}" -eq 1 ] && cmd+=" --rp"
      [ "${save_p}" -eq 1 ] && cmd+=" --p"
      [ "${use_bids_naming}" -eq 1 ] && cmd+=" --bids"
      [ "${save_surf}" -eq 1 ] || [ "${save_hemi}" -eq 1 ] && cmd+=" --surf"
      [ "${save_csf}" -eq 1 ] && cmd+=" --csf"   
      
      cmd+=" --vessel \"${vessel}\" --input \"${input}\" --outdir \"${outmridir}\""
      
      # Execute the command and print errors
      [ "${estimate_seg}" -eq 1 ] && eval "${cmd}"
            
  
    else
      echo "${RED}ERROR: CAT_VolSanlm failed${NC}" >&2
      ((i++))
      continue
    fi
    
    # remove denoised image
    if [ "${use_sanlm}" -eq 1 ]; then
      [ -f "${outmridir}/${sanlm}" ] && rm "${outmridir}/${sanlm}"
    fi
    
    # optionally extract surface
    if [ "${save_surf}" -eq 1 ]; then
        
      # 3. Create hemispheric label maps for cortical surface extraction
      # ----------------------------------------------------------------------
      # check for outputs from previous step
      if [ ! -f "${outmridir}/${hemi_right}" ]; then
        echo "${RED}ERROR: ${cmd_dir}/segment.py failed (file ${outmridir}/${hemi_right} not found)${NC}" >&2
        ((i++))
        continue
      fi

      # 4. Estimate thickness and percentage position maps for each hemisphere
      #  and extract cortical surface and call it as background process to
      # allow parallelization
      # ----------------------------------------------------------------------
      # check for outputs from previous step
      for side in left right; do
        surface_estimation $side $outmridir $outsurfdir $estimate_spherereg &
      done
      
      # use wait to check finishing the background processes
      wait
      
    fi # save_surf

    # remove temporary files if not debugging
    if [ "${debug}" -eq 0 ]; then
      [ -f "${outmridir}/${seg}" ] && rm "${outmridir}/${seg}"
      
      # only remove temporary files if surfaces exist
      if  [[ -f "${outsurfdir}/${mid_left}"  &&  -f "${outsurfdir}/${mid_right}" ]]; then

        if [ "${save_hemi}" -eq 1 ]; then
          file_list='ppm gmt'
        else
          file_list='hemi ppm gmt'
        fi
        for files in ${file_list}t; do
          for side in left right; do
            rm_file=${files}_${side}
            [ -f "${outmridir}/${!rm_file}" ] && rm "${outmridir}/${!rm_file}"
          done
        done
      fi
    fi

    # print execution time per data set
    end=$(date +%s)
    runtime=$((end - start))
    echo "${GREEN}-------------------------------------------------------${NC}"
    echo "${GREEN}Finished after ${runtime}s${NC}"
      
    ((i++))
  done
  
  # print overall execution time for more than one data set
  if [ "$SIZE_OF_ARRAY" -gt 1 ]; then
    end0=`date +%s`
    runtime=$((end0-start0))
    runtime="T1Prep finished after: $(($runtime / 3600))hrs $((($runtime / 60) % 60))min $(($runtime % 60))sec"
    echo "${GREEN}${runtime}${NC}"  
  fi

}

########################################################
# help
########################################################

help() {
cat << EOM
${BOLD}${BLUE}T1Prep Computational Anatomy Pipeline (PyCAT)
---------------------------------------------${NC}

${BOLD}USAGE:${NC}
  ${GREEN}T1Prep [options] <filename(s)>${NC}

${BOLD}DESCRIPTION:${NC}
  Processes T1-weighted brain data for computational anatomy analysis, including segmentation and surface extraction.

${BOLD}OPTIONS:${NC}
  ${BOLD}${YELLOW}General Options:${NC}
  --re-install              Remove the existing installation and reinstall the required Python libraries.
  --python <FILE>           Specify the Python interpreter to use (default: $python).
  --multi <NUMBER>          Set the number of processes for parallelization. Use '-1' to 
                            automatically detect the number of available processors 
                            (default: $multi).
  --debug                   Enable verbose output, retain temporary files, and save additional 
                            debugging information.
  
  ${BOLD}${YELLOW}Save Options:${NC}
  --out-dir <DIR>           Specify the output directory (default: current working directory).
  --no-overwrite <STRING>   Avoid overwriting existing results by checking for the specified 
                            filename pattern.
  --no-surf                 Skip surface and thickness estimation.
  --no-seg                  Skip segmentation processing.
  --no-sphere               Skip spherical surface registration.
  --no-mwp                  Skip the estimation of modulated and warped segmentations.
  --hemisphere              Additionally save hemispheric partitions of the segmentation.
  --pial-white              Additionally extract the pial and white surface
  --wp                      Additionally save warped segmentations.
  --rp                      Additionally save affine-registered segmentations.
  --p                       Additionally save native space segmentations.
  --csf                     Additionally save CSF segmentations (default: only GM/WM are saved).
  --bids                    Use BIDS (Brain Imaging Data Structure) standard for output file 
                            naming conventions (not yet fully working!).

  ${BOLD}${YELLOW}Expert Options:${NC}
  --amap                    Use AMAP segmentation instead of DeepMRIPrep.
  --pre-fwhm <NUMBER>       Set the pre-smoothing FWHM size in CAT_VolMarchingCubes 
                            (default: $pre_fwhm).
  --post-fwhm <NUMBER>      Set the post-smoothing FWHM size in CAT_VolMarchingCubes 
                            (default: $post_fwhm).
  --thickness-fwhm <NUMBER> Set the FWHM size for volumetric thickness smoothing in 
                            CAT_VolThicknessPbt (default: $thickness_fwhm).
  --sharpening <NUMBER>     Set the sharpening level applied to the PPM map by enhancing 
                            differences between the unsmoothed and smoothed PPM maps 
                            (default: $sharpening).
  --thresh <NUMBER>         Specify the isovalue threshold for surface creation in 
                            CAT_VolMarchingCubes (default: $thresh).
  --vessel <NUMBER>         Set the initial white matter (WM) threshold for vessel removal. 
                            Use 0.2 for mild cleanup, 0.5 for strong cleanup, or 0 to disable 
                            vessel removal (default: $vessel).
  --downsample <NUMBER>     Specify the downsampling factor for PPM and GMT maps to reduce 
                            surface intersections (default: $downsample).
  --median-filter <NUMBER>  Specify the number of median filter applications to reduce topology 
                            artifacts.
  --no-thickness-correct    Disable the use of an additional label file for checking whether
                            inner or outer border is reached in order to correct cortical 
                            thickness.
  
  ${BOLD}${YELLOW}Examples:${NC}

${BLUE}${T1prep_dir}/T1Prep --out-dir test_folder sTRIO*.nii${NC}
  Process all files matching the pattern 'sTRIO*.nii'. Generate segmentation and 
  surface maps, saving the results in the 'test_folder' directory.

${BLUE}${T1prep_dir}/T1Prep --no-surf sTRIO*.nii${NC}
  Process all files matching the pattern 'sTRIO*.nii', but skip surface creation. 
  Only segmentation maps are generated and saved in the same directory as the input files.

${BLUE}${T1prep_dir}/T1Prep --python python3.8 --no-overwrite "surf/lh.thickness." sTRIO*.nii${NC}
  Process all files matching the pattern 'sTRIO*.nii' and use python3.8. Skip processing 
  for files where 'surf/lh.thickness.*' already exists, and save new results in the same 
  directory as the input files.

${BLUE}${T1prep_dir}/T1Prep --multi -1 --p --csf sTRIO*.nii${NC}
  Process all files matching the pattern 'sTRIO*.nii'. Additionally save segmentations 
  in native space, including CSF segmentation. The processing pipeline involves two stages 
  of parallelization:
  
  1. **Segmentation (Python-based)**: Runs best with about 24GB of memory per process. 
     The number of processes is automatically estimated based on available memory to 
     optimize resource usage.

  2. **Surface Extraction**: This stage does not require significant memory and is fully 
     distributed across all available processors.

  If "--multi" is set to a specific number (e.g., 8), the system still estimates memory-based 
  constraints for segmentation parallelization. However, the specified number of processes 
  (e.g., 8) will be used for surface extraction, ensuring efficient parallelization across 
  the two stages.
    
${BOLD}PURPOSE:${NC}
  This script facilitates the analysis of T1-weighted brain images by providing tools for 
  segmentation, surface mapping, and more.

${BOLD}INPUT:${NC}
  Accepts NIfTI files as input.

${BOLD}OUTPUT:${NC}
  Produces segmented images and surface extractions.

${BOLD}USED FUNCTIONS:${NC}
  - CAT_VolAmap
  - CAT_VolSanlm
  - CAT_VolThicknessPbt
  - CAT_VolMarchingCubes
  - CAT_3dVol2Surf
  - CAT_SurfDistance
  - CAT_Central2Pial
  - ${cmd_dir}/segment.py
  - ${cmd_dir}/utils.py
  - ${cmd_dir}/parallelize

${BOLD}Author:${NC}
  Christian Gaser (christian.gaser@uni-jena.de)

EOM

check_python
check_python_cmd

# Check whether local Python environment exists
if [ ! -d "${T1prep_env}" ]; then

  # Prompt the user with a Y/N question
  echo "${RED}${BOLD}Local Python environment "${T1prep_env}" not found.${NC}"
  echo "Do you want to install required Python libraries? (Y/N)"
  read -r response
  
  # Check if the user's answer is 'Y'
  case "$response" in
    [Yy]*)
      check_python_module venv
      check_python_module pip
      check_python_libraries
      ;;
  esac
fi

}

########################################################
# call main program
########################################################

main "${@}"
  