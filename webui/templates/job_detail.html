<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Job {{ job.id }}</title>
  <link rel="stylesheet" href="/static/styles.css">
</head>
<body data-theme="dark">
  <div class="container">
    <header>
      <div>
        <h1>Job {{ job.id }}</h1>
        <p><a href="/jobs">Back to jobs</a> | <a href="/">New job</a></p>
      </div>
      <button class="theme-toggle" type="button" id="theme-toggle">Dark mode</button>
    </header>

  <div class="card meta">
    <p><strong>Status:</strong> <span id="job-status">{{ job.status }}</span></p>
    <p><strong>Phase:</strong> <span id="job-phase">Initializing</span></p>
    <p><strong>Created:</strong> {{ job.created_at }}</p>
    <p><strong>Scheduled for:</strong> {{ job.scheduled_for or "" }}</p>
    <p><strong>Started:</strong> <span id="job-started">{{ job.started_at or "" }}</span></p>
    <p><strong>Finished:</strong> <span id="job-finished">{{ job.finished_at or "" }}</span></p>
    <p><strong>Return code:</strong> <span id="job-return-code">{{ job.return_code if job.return_code is not none else "" }}</span></p>
  </div>

  <h2>Command</h2>
  <pre>{{ job.command_display }}</pre>

  <h2>Progress</h2>
  <div class="card progress-panel">
    <div class="progress-track">
      <div id="progress-bar" class="progress-bar"></div>
    </div>
    <div class="progress-meta">
      <span id="progress-label">Waiting for progressâ€¦</span>
      <span id="progress-percent">0%</span>
    </div>
    <div class="progress-detail" style="margin-top: 0.5em; font-size: 0.9em; opacity: 0.8;">
      <span id="progress-ratio"></span>
    </div>
  </div>

  <h2>Log</h2>
  <pre id="log-output">{{ log_content }}</pre>

  <script>
    const themeToggle = document.getElementById("theme-toggle");
    const savedTheme = localStorage.getItem("t1prep-theme") || "dark";
    document.body.setAttribute("data-theme", savedTheme);
    themeToggle.textContent = savedTheme === "dark" ? "Light mode" : "Dark mode";

    themeToggle.addEventListener("click", () => {
      const next = document.body.getAttribute("data-theme") === "dark" ? "light" : "dark";
      document.body.setAttribute("data-theme", next);
      localStorage.setItem("t1prep-theme", next);
      themeToggle.textContent = next === "dark" ? "Light mode" : "Dark mode";
    });

    const logOutput = document.getElementById("log-output");
    const progressBar = document.getElementById("progress-bar");
    const progressLabel = document.getElementById("progress-label");
    const progressPercent = document.getElementById("progress-percent");
    const progressRatio = document.getElementById("progress-ratio");
    const jobStatus = document.getElementById("job-status");
    const jobPhase = document.getElementById("job-phase");
    const jobStarted = document.getElementById("job-started");
    const jobFinished = document.getElementById("job-finished");
    const jobReturnCode = document.getElementById("job-return-code");

    const pollIntervalMs = 2000;
    let isFinished = {{ 'true' if job.status in ('finished', 'failed') else 'false' }};

    async function refreshLog() {
      if (isFinished) return;
      try {
        const response = await fetch(window.location.href, { headers: { "X-Requested-With": "fetch" } });
        if (!response.ok) return;
        const text = await response.text();
        const parser = new DOMParser();
        const doc = parser.parseFromString(text, "text/html");
        const updated = doc.getElementById("log-output");
        if (updated && logOutput) {
          logOutput.textContent = updated.textContent;
        }
      } catch (error) {
        // Ignore polling errors.
      }
    }

    async function refreshProgress() {
      if (isFinished) return;
      try {
        const response = await fetch(`${window.location.pathname}/progress`);
        if (!response.ok) return;
        const data = await response.json();
        if (!data.available) {
          return;
        }
        const percent = data.percent ?? 0;
        progressBar.style.width = `${percent}%`;
        if (data.failed) {
          progressBar.classList.add("failed");
          progressLabel.textContent = "Failed";
        } else {
          progressBar.classList.remove("failed");
          progressLabel.textContent = data.label || "Progress";
        }
        progressPercent.textContent = `${percent}%`;
        if (data.done !== undefined && data.total !== undefined) {
          progressRatio.textContent = `${data.done} / ${data.total} items`;
        }
      } catch (error) {
        // Ignore polling errors.
      }
    }

    async function refreshStatus() {
      try {
        const response = await fetch(`${window.location.pathname}/status`);
        if (!response.ok) return;
        const data = await response.json();

        if (data.status) {
          jobStatus.textContent = data.status;
          if (data.status === "finished") {
            jobStatus.style.color = "#4caf50";
            isFinished = true;
            progressBar.style.width = "100%";
            progressPercent.textContent = "100%";
            progressLabel.textContent = "Completed";
          } else if (data.status === "failed") {
            jobStatus.style.color = "#f44336";
            isFinished = true;
            progressBar.classList.add("failed");
            progressLabel.textContent = "Failed";
          } else if (data.status === "running") {
            jobStatus.style.color = "#2196f3";
          }
        }
        if (data.phase) {
          jobPhase.textContent = data.phase;
        }
        if (data.started_at) {
          jobStarted.textContent = data.started_at;
        }
        if (data.finished_at) {
          jobFinished.textContent = data.finished_at;
        }
        if (data.return_code !== null && data.return_code !== undefined) {
          jobReturnCode.textContent = data.return_code;
        }
      } catch (error) {
        // Ignore polling errors.
      }
    }

    // Initial refresh
    refreshStatus();
    refreshProgress();

    // Set up polling
    setInterval(refreshLog, pollIntervalMs);
    setInterval(refreshProgress, pollIntervalMs);
    setInterval(refreshStatus, pollIntervalMs);
  </script>
  </div>
</body>
</html>
