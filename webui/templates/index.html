<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>T1Prep Web UI</title>
  <link rel="icon" type="image/png" href="/static/icons8-gehirn-50.png">
  <link rel="stylesheet" href="/static/styles.css">
</head>
<body data-theme="dark">
  <div class="container">
    <header>
      <div>
        <h1>T1Prep Web UI</h1>
        <p>Upload NIfTI files and configure options. Scheduling is optional.</p>
        <p class="hint"><kbd>Tab</kbd> to confirm field entries and update file list &bull; <kbd>Return</kbd> to submit the job &bull; <span class="required">*</span> required field</p>
      </div>
      <button class="theme-toggle" type="button" id="theme-toggle">Dark mode</button>
    </header>

    <form id="t1prep-form" action="/submit" method="post" enctype="multipart/form-data">
      <div id="user-error-message" class="user-error-message" style="display:none;color:#f55;margin-bottom:1em;"></div>
    <fieldset>
      <legend>Inputs</legend>

      <fieldset class="sub-fieldset" id="input-files-fieldset">
        <legend>Input Files <span class="required">*</span></legend>
        <label>
          Input NIfTI files
          <input id="file-input" class="file-input-hidden" type="file" name="inputs" multiple accept=".nii,.nii.gz,application/gzip,application/x-gzip">
          <div class="input-with-help">
            <div class="file-input-row">
              <button id="file-button" type="button" class="file-button" data-help-target="input-files-help">Select files</button>
              <span id="file-summary" class="file-summary">No files selected</span>
            </div>
            <div id="input-files-help" class="help-box" role="tooltip">
              Input T1-weighted NIfTI files (.nii or .nii.gz).
            </div>
          </div>
        </label>
        <div id="dropzone" class="dropzone">
          Drag & drop files here
        </div>
        <label>
          Or select by folder + pattern
          <div class="input-with-help">
            <span class="input-icon" data-icon="ðŸ“"><input type="text" name="folder_root" placeholder="/path/to/folder" data-help-target="folder-root-help"></span>
            <div id="folder-root-help" class="help-box" role="tooltip">
              Root folder to search for input files when using a pattern.
            </div>
          </div>
        </label>
        <label>
          File pattern (recursive)
          <div class="input-with-help">
            <span class="input-icon" data-icon="ðŸ”"><input type="text" name="file_pattern" placeholder="**/*.nii*" data-help-target="file-pattern-help"></span>
            <div id="file-pattern-help" class="help-box" role="tooltip">
              Recursive glob pattern used with the folder above.
            </div>
          </div>
        </label>
        <input type="hidden" name="removed_pattern_files" id="removed-pattern-files" value="">
        <div id="file-list-toolbar" class="file-list-toolbar" style="display: none;">
          <button id="remove-selected-btn" type="button" class="remove-selected-btn" disabled>Remove selected</button>
          <span class="selection-hint">Click to select, Shift+click for range</span>
        </div>
        <div id="combined-file-list" class="file-list"></div>
      </fieldset>

      <fieldset class="sub-fieldset">
        <legend>Output Directory</legend>
        <label>
          Auto-filled when using folder+pattern
          <div class="input-with-help">
            <span class="input-icon input-required" data-icon="ðŸ’¾"><input type="text" name="out_dir" required placeholder="/path/to/output" aria-describedby="out-dir-help" data-help-target="out-dir-help"></span>
            <div id="out-dir-help" class="help-box" role="tooltip">
              Set the base output directory. BIDS subfolders are appended when BIDS naming is used.
            </div>
          </div>
        </label>
      </fieldset>

      <fieldset class="sub-fieldset">
        <legend>Scheduling</legend>
        <label>
          Start at (optional)
          <div class="input-with-help">
            <span class="input-icon" data-icon="ðŸ•"><input type="datetime-local" name="start_at" data-help-target="start-at-help"></span>
            <div id="start-at-help" class="help-box" role="tooltip">
              Schedule the job to start at a specific date and time.
            </div>
          </div>
        </label>
      </fieldset>
    </fieldset>

    <fieldset>
      <legend>General Options</legend>
      <label class="toggle help-anchor" data-help-target="debug-help">
        <input type="checkbox" name="--debug" value="1" {% if debug %}checked{% endif %}>
        <span class="toggle-track" aria-hidden="true"></span>
        <span class="toggle-text">Debug</span>
        <div id="debug-help" class="help-box" role="tooltip">
          Enable verbose output, retain temporary files, and save debugging information.
        </div>
      </label>
      <label>
        Parallel jobs
        <div class="input-with-help">
          <span class="input-icon" data-icon="âš¡"><input type="number" name="--multi" value="{{ multi }}" placeholder="-1 for auto" data-help-target="multi-help"></span>
          <div id="multi-help" class="help-box" role="tooltip">
            Set the maximum number of parallel jobs. Use -1 to auto-detect CPU cores.
          </div>
        </div>
      </label>
      <label>
        Minimum memory per job (GB)
        <div class="input-with-help">
          <span class="input-icon" data-icon="ðŸ§ "><input type="number" name="--min-memory" value="{{ min_memory }}" step="1" placeholder="24" data-help-target="min-memory-help"></span>
          <div id="min-memory-help" class="help-box" role="tooltip">
            Minimum memory in GB per job. Increase if the system runs low on memory.
          </div>
        </div>
      </label>
    </fieldset>

    <fieldset class="collapsible collapsed" id="save-options-fieldset">
      <legend class="collapsible-toggle">
        <span class="toggle-icon">â–¶</span> Save Options
      </legend>
      <div class="collapsible-content">
      <label>
        No-overwrite pattern
        <div class="input-with-help">
          <span class="input-icon" data-icon="ðŸ›¡ï¸"><input type="text" name="--no-overwrite" value="{{ no_overwrite }}" placeholder="surf/lh.thickness." data-help-target="no-overwrite-help"></span>
          <div id="no-overwrite-help" class="help-box" role="tooltip">
            Prevent overwriting results by checking for the given filename pattern.
          </div>
        </div>
      </label>

      <fieldset class="sub-fieldset">
        <legend>Processing Options</legend>
        <div class="atlas-panel options-panel">
          <div class="checkbox-row">
          <label class="toggle help-anchor" data-help-target="amap-help"><span class="toggle-text">AMAP segmentation</span><input type="checkbox" name="--amap" value="1" {% if amap %}checked{% endif %}><span class="toggle-track" aria-hidden="true"></span><div id="amap-help" class="help-box" role="tooltip">Use DeepMRIPrep segmentation only as initialization, followed by AMAP segmentation.</div></label>
          <label class="toggle help-anchor" data-help-target="bids-help"><span class="toggle-text">BIDS naming</span><input type="checkbox" name="--bids" value="1" {% if use_bids %}checked{% endif %}><span class="toggle-track" aria-hidden="true"></span><div id="bids-help" class="help-box" role="tooltip">Use BIDS derivatives naming conventions instead of CAT12 style.</div></label>
          <label class="toggle help-anchor" data-help-target="gz-help"><span class="toggle-text">Save .nii.gz</span><input type="checkbox" name="--gz" value="1" {% if gz %}checked{% endif %}><span class="toggle-track" aria-hidden="true"></span><div id="gz-help" class="help-box" role="tooltip">Save images in compressed NIfTI format (*.nii.gz).</div></label>
          <label class="toggle help-anchor" data-help-target="no-surf-help"><span class="toggle-text">No surface estimation</span><input type="checkbox" name="--no-surf" value="1" {% if no_surf %}checked{% endif %}><span class="toggle-track" aria-hidden="true"></span><div id="no-surf-help" class="help-box" role="tooltip">Skip surface and cortical thickness estimation.</div></label>
          <label class="toggle help-anchor" data-help-target="mwp-help"><span class="toggle-text">Save modulated/warped seg</span><input type="checkbox" name="save_mwp" value="1" {% if save_mwp %}checked{% endif %}><span class="toggle-track" aria-hidden="true"></span><div id="mwp-help" class="help-box" role="tooltip">Save modulated and warped segmentations.</div></label>
          <label class="toggle help-anchor" data-help-target="wp-help"><span class="toggle-text">Save warped seg</span><input type="checkbox" name="--wp" value="1" {% if wp %}checked{% endif %}><span class="toggle-track" aria-hidden="true"></span><div id="wp-help" class="help-box" role="tooltip">Additionally save warped segmentations.</div></label>
          <label class="toggle help-anchor" data-help-target="rp-help"><span class="toggle-text">Save affine seg</span><input type="checkbox" name="--rp" value="1" {% if rp %}checked{% endif %}><span class="toggle-track" aria-hidden="true"></span><div id="rp-help" class="help-box" role="tooltip">Additionally save affine-registered segmentations.</div></label>
          <label class="toggle help-anchor" data-help-target="p-help"><span class="toggle-text">Save native seg</span><input type="checkbox" name="--p" value="1" {% if p %}checked{% endif %}><span class="toggle-track" aria-hidden="true"></span><div id="p-help" class="help-box" role="tooltip">Additionally save native-space segmentations.</div></label>
          <label class="toggle help-anchor" data-help-target="lesions-help"><span class="toggle-text">Save lesion seg</span><input type="checkbox" name="--lesions" value="1" {% if lesions %}checked{% endif %}><span class="toggle-track" aria-hidden="true"></span><div id="lesions-help" class="help-box" role="tooltip">Additionally save WMH lesion segmentations.</div></label>
          </div>
        </div>
      </fieldset>

      <fieldset class="sub-fieldset">
        <legend class="help-anchor" data-help-target="volume-atlas-help">
          Volume Atlases
          <div id="volume-atlas-help" class="help-box" role="tooltip">
            Specify volumetric atlases to estimate ROI volumes.
          </div>
        </legend>
        <div class="atlas-panel atlas-panel-overlay">
          <div class="atlas-header">Available atlases</div>
          <div class="atlas-grid-scroll">
            <div class="atlas-grid">
              {% for atlas_name in atlas_names %}
                <label class="toggle help-anchor" data-help-target="atlas-help-{{ atlas_name }}" data-atlas-help="{{ atlas_name }}">
                  <span class="toggle-text">{{ atlas_name }}</span>
                  <input type="checkbox" name="atlas_choice" value="{{ atlas_name }}" {% if atlas_name in atlas_selected %}checked{% endif %}>
                  <span class="toggle-track" aria-hidden="true"></span>
                  <div id="atlas-help-{{ atlas_name }}" class="help-box atlas-help" role="tooltip">
                    Loading atlas details...
                  </div>
                </label>
              {% endfor %}
            </div>
          </div>
        </div>
        <label>
          Custom atlas file (.nii or .nii.gz)
          <input id="atlas-file-input" class="file-input-hidden" type="file" name="atlas_file" accept=".nii,.nii.gz,.gz,application/gzip,application/x-gzip">
          <div class="input-with-help">
            <div class="file-input-row">
              <button id="atlas-file-button" type="button" class="file-button" data-help-target="atlas-file-help">Select file</button>
              <span id="atlas-file-summary" class="file-summary">No file selected</span>
            </div>
            <div id="atlas-file-help" class="help-box" role="tooltip">
              Optional custom volumetric atlas file (.nii or .nii.gz).
            </div>
          </div>
        </label>
      </fieldset>

      <fieldset class="sub-fieldset">
        <legend class="help-anchor" data-help-target="surface-atlas-help">
          Surface Atlases
          <div id="surface-atlas-help" class="help-box" role="tooltip">
            Specify surface atlases for labeling in surface space.
          </div>
        </legend>
        <div class="atlas-panel">
          <div class="atlas-header">Available atlases</div>
          <div class="atlas-grid">
            {% for atlas_name in surface_atlas_names %}
              <label class="toggle">
                <span class="toggle-text">{{ atlas_name }}</span>
                <input type="checkbox" name="surface_atlas_choice" value="{{ atlas_name }}" {% if atlas_name in surface_atlas_selected %}checked{% endif %}>
                <span class="toggle-track" aria-hidden="true"></span>
              </label>
            {% endfor %}
          </div>
        </div>
        <label>
          Custom atlas file (.annot)
          <input id="surface-atlas-file-input" class="file-input-hidden" type="file" name="surface_atlas_file" accept=".annot">
          <div class="input-with-help">
            <div class="file-input-row">
              <button id="surface-atlas-file-button" type="button" class="file-button" data-help-target="surface-atlas-file-help">Select file</button>
              <span id="surface-atlas-file-summary" class="file-summary">No file selected</span>
            </div>
            <div id="surface-atlas-file-help" class="help-box" role="tooltip">
              Optional custom surface atlas file (.annot).
            </div>
          </div>
        </label>
      </fieldset>

      </div>
    </fieldset>

    <fieldset class="collapsible collapsed" id="expert-options-fieldset">
      <legend class="collapsible-toggle">
        <span class="toggle-icon">â–¶</span> Expert Options
      </legend>
      <div class="collapsible-content">
        <fieldset class="sub-fieldset">
          <legend>Processing Options</legend>
          <div class="atlas-panel options-panel">
            <div class="checkbox-row">
            <label class="toggle help-anchor" data-help-target="no-sphere-help"><span class="toggle-text">No spherical registration</span><input type="checkbox" name="--no-sphere-reg" value="1" {% if no_sphere_reg %}checked{% endif %}><span class="toggle-track" aria-hidden="true"></span><div id="no-sphere-help" class="help-box" role="tooltip">Skip spherical surface registration.</div></label>
            <label class="toggle help-anchor" data-help-target="no-seg-help"><span class="toggle-text">No segmentation</span><input type="checkbox" name="--no-seg" value="1" {% if no_seg %}checked{% endif %}><span class="toggle-track" aria-hidden="true"></span><div id="no-seg-help" class="help-box" role="tooltip">Skip tissue segmentation processing.</div></label>
            <label class="toggle help-anchor" data-help-target="hemi-help"><span class="toggle-text">Save hemispheric seg</span><input type="checkbox" name="--hemi" value="1" {% if hemi %}checked{% endif %}><span class="toggle-track" aria-hidden="true"></span><div id="hemi-help" class="help-box" role="tooltip">Save hemispheric (lh/rh) partitions of the segmentation.</div></label>
            <label class="toggle help-anchor" data-help-target="pial-white-help"><span class="toggle-text">Pial + white surfaces</span><input type="checkbox" name="--pial-white" value="1" {% if pial_white %}checked{% endif %}><span class="toggle-track" aria-hidden="true"></span><div id="pial-white-help" class="help-box" role="tooltip">Additionally estimate pial and white matter surfaces.</div></label>
            <label class="toggle help-anchor" data-help-target="csf-help"><span class="toggle-text">Save CSF seg</span><input type="checkbox" name="--csf" value="1" {% if csf %}checked{% endif %}><span class="toggle-track" aria-hidden="true"></span><div id="csf-help" class="help-box" role="tooltip">Additionally save CSF segmentations.</div></label>
            </div>
          </div>
        </fieldset>
        </div>
      </fieldset>

    <div class="actions">
      <button type="submit">Create Job</button>
      <a href="/jobs">View Jobs</a>
    </div>
  </form>

  <script>
    // Show user-facing error message
    function showUserError(msg) {
      const el = document.getElementById("user-error-message");
      el.textContent = msg;
      el.style.display = msg ? "block" : "none";
    }
    function clearUserError() {
      showUserError("");
    }
    
    // Always collapse 'Save Options' on first load unless user has set otherwise
    (function ensureSaveOptionsCollapsed() {
      const key = 't1prep-save-options-fieldset-collapsed';
      if (localStorage.getItem(key) === null) {
        localStorage.setItem(key, 'true');
      }
    })();
    
    const themeToggle = document.getElementById("theme-toggle");
    const savedTheme = localStorage.getItem("t1prep-theme") || "dark";
    document.body.setAttribute("data-theme", savedTheme);
    themeToggle.textContent = savedTheme === "dark" ? "Light mode" : "Dark mode";

    themeToggle.addEventListener("click", () => {
      const next = document.body.getAttribute("data-theme") === "dark" ? "light" : "dark";
      document.body.setAttribute("data-theme", next);
      localStorage.setItem("t1prep-theme", next);
      themeToggle.textContent = next === "dark" ? "Light mode" : "Dark mode";
    });

    // Collapsible fieldset toggle
    document.querySelectorAll("fieldset.collapsible .collapsible-toggle").forEach(legend => {
      legend.addEventListener("click", () => {
        const fieldset = legend.closest("fieldset.collapsible");
        fieldset.classList.toggle("collapsed");
        // Save state
        const id = fieldset.id;
        if (id) {
          localStorage.setItem(`t1prep-${id}-collapsed`, fieldset.classList.contains("collapsed"));
        }
      });
    });

    // Restore collapsed state from localStorage
    document.querySelectorAll("fieldset.collapsible").forEach(fieldset => {
      const id = fieldset.id;
      if (id) {
        const saved = localStorage.getItem(`t1prep-${id}-collapsed`);
        if (saved === "false") {
          fieldset.classList.remove("collapsed");
        }
      }
    });

    const fileInput = document.getElementById("file-input");
    const fileButton = document.getElementById("file-button");
    const fileSummary = document.getElementById("file-summary");
    const dropzone = document.getElementById("dropzone");
    const combinedFileList = document.getElementById("combined-file-list");
    const fileListToolbar = document.getElementById("file-list-toolbar");
    const removeSelectedBtn = document.getElementById("remove-selected-btn");
    const removedPatternField = document.getElementById("removed-pattern-files");
    const folderRootInput = document.querySelector("input[name='folder_root']");
    const filePatternInput = document.querySelector("input[name='file_pattern']");
    const outDirInput = document.querySelector("input[name='out_dir']");
    const helpAnchors = document.querySelectorAll("[data-help-target]");
    const atlasHelpCache = new Map();
    let selectedFiles = [];  // Uploaded files (File objects)
    let patternFiles = [];   // Pattern-matched files (path strings)
    let removedPattern = new Set();
    let combinedSelection = new Set();  // Track selected items (index strings like "upload-0" or "pattern-/path/to/file")
    let lastClickedItem = null;

    // Set up remove button click handler
    removeSelectedBtn.addEventListener("click", () => {
      // Separate selected items by type
      const uploadIndicesToRemove = [];
      const patternPathsToRemove = [];
      combinedSelection.forEach(key => {
        if (key.startsWith("upload-")) {
          uploadIndicesToRemove.push(parseInt(key.replace("upload-", "")));
        } else if (key.startsWith("pattern-")) {
          patternPathsToRemove.push(key.replace("pattern-", ""));
        }
      });
      // Remove uploaded files (in reverse order to preserve indices)
      uploadIndicesToRemove.sort((a, b) => b - a).forEach(i => selectedFiles.splice(i, 1));
      // Mark pattern files as removed
      patternPathsToRemove.forEach(path => removedPattern.add(path));
      removedPatternField.value = Array.from(removedPattern).join("||");
      syncFileInput();
      renderCombinedFileList();
    });

    // Set default output directory on page load
    (async function initDefaultOutput() {
      if (!outDirInput.value.trim()) {
        try {
          const response = await fetch("/get-default-output");
          if (response.ok) {
            const data = await response.json();
            if (data.default_output) {
              outDirInput.value = data.default_output;
            }
          } else {
            showUserError("Failed to fetch default output directory (server error)");
          }
        } catch (error) {
          showUserError("Network error while fetching default output directory.");
        }
      }
    })();

    // Auto-populate output directory from file path
    async function suggestOutputDir(pathValue, force = false) {
      if (!pathValue) return;
      // Skip if already set and not forcing
      if (!force && outDirInput.value.trim()) return;
      const url = new URL("/resolve-dirname", window.location.origin);
      url.searchParams.set("path", pathValue);
      try {
        const response = await fetch(url.toString());
        if (!response.ok) {
          showUserError("Failed to suggest output directory (server error)");
          return;
        }
        const data = await response.json();
        if (data.dirname) {
          outDirInput.value = data.dirname;
        } else {
          showUserError("No output directory could be suggested for this path.");
        }
      } catch (error) {
        showUserError("Network error while suggesting output directory.");
      }
    }

    function syncFileInput() {
      const dataTransfer = new DataTransfer();
      selectedFiles.forEach((file) => dataTransfer.items.add(file));
      fileInput.files = dataTransfer.files;
    }

    function renderCombinedFileList() {
      combinedFileList.innerHTML = "";
      combinedSelection.clear();
      lastClickedItem = null;

      // Reset button state since selection is cleared
      removeSelectedBtn.disabled = true;
      removeSelectedBtn.textContent = "Remove selected";

      const visiblePatternFiles = patternFiles.filter((path) => !removedPattern.has(path));
      const totalFiles = selectedFiles.length + visiblePatternFiles.length;

      // Hide toolbar when no files
      if (totalFiles === 0) {
        fileListToolbar.style.display = "none";
      }

      // Update summary to show total file count from all sources
      if (totalFiles === 0) {
        fileSummary.textContent = "No files selected";
      } else if (totalFiles === 1) {
        // Show single filename
        if (selectedFiles.length === 1) {
          fileSummary.textContent = selectedFiles[0].name;
        } else {
          fileSummary.textContent = visiblePatternFiles[0].split("/").pop();
        }
      } else {
        // Show total count with breakdown if from multiple sources
        if (selectedFiles.length > 0 && visiblePatternFiles.length > 0) {
          fileSummary.textContent = `${totalFiles} files (${selectedFiles.length} uploaded + ${visiblePatternFiles.length} from pattern)`;
        } else {
          fileSummary.textContent = `${totalFiles} files selected`;
        }
      }

      if (totalFiles === 0) return;

      // Show the toolbar when there are files
      fileListToolbar.style.display = "flex";

      // Build combined items array: [{type, index, name, fullPath}]
      const items = [];
      selectedFiles.forEach((file, idx) => {
        items.push({ type: "upload", index: idx, name: file.name, fullPath: null, key: `upload-${idx}` });
      });
      visiblePatternFiles.forEach((path, idx) => {
        const filename = path.split("/").pop();
        items.push({ type: "pattern", index: idx, name: filename, fullPath: path, key: `pattern-${path}` });
      });

      // Render items
      items.forEach((itemData, globalIndex) => {
        const item = document.createElement("div");
        item.className = "file-list-item";
        item.dataset.key = itemData.key;
        item.dataset.globalIndex = globalIndex;
        item.textContent = itemData.name;
        item.title = itemData.fullPath || itemData.name;
        if (itemData.type === "pattern") {
          item.classList.add("pattern-file");
        }
        item.addEventListener("click", (e) => {
          if (e.shiftKey && lastClickedItem !== null) {
            // Range selection
            const lastIdx = lastClickedItem;
            const start = Math.min(lastIdx, globalIndex);
            const end = Math.max(lastIdx, globalIndex);
            for (let i = start; i <= end; i++) {
              combinedSelection.add(items[i].key);
            }
          } else if (e.ctrlKey || e.metaKey) {
            // Toggle selection
            if (combinedSelection.has(itemData.key)) {
              combinedSelection.delete(itemData.key);
            } else {
              combinedSelection.add(itemData.key);
            }
          } else {
            // Single selection
            combinedSelection.clear();
            combinedSelection.add(itemData.key);
          }
          lastClickedItem = globalIndex;
          updateSelectionUI();
        });
        combinedFileList.appendChild(item);
      });

      function updateSelectionUI() {
        combinedFileList.querySelectorAll(".file-list-item").forEach(el => {
          el.classList.toggle("selected", combinedSelection.has(el.dataset.key));
        });
        removeSelectedBtn.disabled = combinedSelection.size === 0;
        removeSelectedBtn.textContent = combinedSelection.size > 0 
          ? `Remove selected (${combinedSelection.size})` 
          : "Remove selected";
      }
    }

    async function updatePatternList() {
      const folderRoot = folderRootInput.value.trim();
      const filePattern = filePatternInput.value.trim();
      if (!folderRoot || !filePattern) {
        patternFiles = [];
        removedPattern.clear();
        removedPatternField.value = "";
        renderCombinedFileList();
        return;
      }
      const url = new URL("/resolve-pattern", window.location.origin);
      url.searchParams.set("folder_root", folderRoot);
      url.searchParams.set("file_pattern", filePattern);
      try {
        const response = await fetch(url.toString());
        if (!response.ok) return;
        const data = await response.json();
        patternFiles = Array.isArray(data.files) ? data.files : [];
        const stillRemoved = new Set();
        removedPattern.forEach((path) => {
          if (patternFiles.includes(path)) {
            stillRemoved.add(path);
          }
        });
        removedPattern = stillRemoved;
        removedPatternField.value = Array.from(removedPattern).join("||");
        renderCombinedFileList();
        clearInputError();
        // Auto-fill output directory from first file's dirname
        if (patternFiles.length > 0) {
          suggestOutputDir(patternFiles[0], true);
        }
      } catch (error) {
        // Ignore preview errors.
      }
    }

    fileInput.addEventListener("change", async () => {
      selectedFiles = Array.from(fileInput.files);
      renderCombinedFileList();
      clearInputError();
      // For uploaded files, browsers don't expose full path for security.
      // Set a default output directory if not already set.
      if (selectedFiles.length > 0 && !outDirInput.value.trim()) {
        try {
          const response = await fetch("/get-default-output");
          if (response.ok) {
            const data = await response.json();
            if (data.default_output) {
              outDirInput.value = data.default_output;
            }
          }
        } catch (error) {
          // Ignore errors
        }
      }
    });

    folderRootInput.addEventListener("blur", () => {
      updatePatternList();
      suggestOutputDir(folderRootInput.value.trim());
    });
    filePatternInput.addEventListener("blur", updatePatternList);

    helpAnchors.forEach((anchor) => {
      const helpId = anchor.getAttribute("data-help-target");
      const helpBox = helpId ? document.getElementById(helpId) : null;
      if (!helpBox) return;
      let timer = null;

      const showHelp = () => {
        if (timer) return;
        timer = window.setTimeout(() => {
          if (helpBox.classList.contains("atlas-help")) {
            const rect = anchor.getBoundingClientRect();
            const maxWidth = 520;
            const left = Math.max(12, Math.min(rect.left, window.innerWidth - maxWidth - 12));
            const top = rect.bottom + 8;
            helpBox.style.position = "fixed";
            helpBox.style.left = `${left}px`;
            helpBox.style.top = `${top}px`;
          }
          helpBox.classList.add("visible");
          timer = null;
        }, 220);
      };

      const hideHelp = () => {
        if (timer) {
          window.clearTimeout(timer);
          timer = null;
        }
        helpBox.classList.remove("visible");
        if (helpBox.classList.contains("atlas-help")) {
          helpBox.style.left = "";
          helpBox.style.top = "";
          helpBox.style.position = "";
        }
      };

      anchor.addEventListener("mouseenter", showHelp);
      anchor.addEventListener("mouseleave", hideHelp);
      anchor.addEventListener("focusin", showHelp);
      anchor.addEventListener("focusout", hideHelp);
    });

    function setAtlasHelpText(helpBox, text) {
      helpBox.textContent = text;
    }

    async function loadAtlasHelp(name, helpBox) {
      if (!name || !helpBox) return;
      if (helpBox.dataset.currentName === name) return;
      helpBox.dataset.currentName = name;

      if (atlasHelpCache.has(name)) {
        setAtlasHelpText(helpBox, atlasHelpCache.get(name));
        return;
      }

      setAtlasHelpText(helpBox, "Loading atlas details...");
      try {
        const url = new URL("/atlas-help", window.location.origin);
        url.searchParams.set("name", name);
        const response = await fetch(url.toString());
        if (!response.ok) {
          throw new Error("Atlas help not available");
        }
        const data = await response.json();
        const text = data && data.text ? data.text : "No description available.";
        atlasHelpCache.set(name, text);
        if (helpBox.dataset.currentName === name) {
          setAtlasHelpText(helpBox, text);
        }
      } catch (error) {
        if (helpBox.dataset.currentName === name) {
          setAtlasHelpText(helpBox, "No description available.");
        }
      }
    }

    document.querySelectorAll("[data-atlas-help]").forEach((item) => {
      const name = item.getAttribute("data-atlas-help");
      const helpId = item.getAttribute("data-help-target");
      const helpBox = helpId ? document.getElementById(helpId) : null;
      if (!name || !helpBox) return;
      item.addEventListener("mouseenter", () => loadAtlasHelp(name, helpBox));
      item.addEventListener("focusin", () => loadAtlasHelp(name, helpBox));
    });

    fileButton.addEventListener("click", () => {
      fileInput.click();
    });

    // Form validation: ensure at least one input file is selected
    const form = document.getElementById("t1prep-form");
    const inputFilesFieldset = document.getElementById("input-files-fieldset");

    function clearInputError() {
      const hasUploadedFiles = selectedFiles.length > 0;
      const hasPatternFiles = patternFiles.filter((p) => !removedPattern.has(p)).length > 0;
      if (hasUploadedFiles || hasPatternFiles) {
        inputFilesFieldset.classList.remove("error");
      }
    }

    form.addEventListener("submit", (event) => {
      const hasUploadedFiles = selectedFiles.length > 0;
      const hasPatternFiles = patternFiles.filter((p) => !removedPattern.has(p)).length > 0;

      if (!hasUploadedFiles && !hasPatternFiles) {
        event.preventDefault();
        inputFilesFieldset.classList.add("error");
        alert("Please select at least one input file or specify a folder with pattern.");
        return false;
      }
      inputFilesFieldset.classList.remove("error");
    });

    dropzone.addEventListener("dragover", (event) => {
      event.preventDefault();
      dropzone.classList.add("dragover");
    });

    dropzone.addEventListener("dragleave", () => {
      dropzone.classList.remove("dragover");
    });

    dropzone.addEventListener("drop", (event) => {
      event.preventDefault();
      dropzone.classList.remove("dragover");
      if (!event.dataTransfer || !event.dataTransfer.files.length) return;
      selectedFiles = Array.from(event.dataTransfer.files);
      syncFileInput();
      renderCombinedFileList();
      clearInputError();
    });

    // Custom atlas file button
    const atlasFileInput = document.getElementById("atlas-file-input");
    const atlasFileButton = document.getElementById("atlas-file-button");
    const atlasFileSummary = document.getElementById("atlas-file-summary");

    atlasFileButton.addEventListener("click", () => {
      atlasFileInput.click();
    });

    atlasFileInput.addEventListener("change", () => {
      if (atlasFileInput.files.length > 0) {
        atlasFileSummary.textContent = atlasFileInput.files[0].name;
      } else {
        atlasFileSummary.textContent = "No file selected";
      }
    });

    // Custom surface atlas file button
    const surfaceAtlasFileInput = document.getElementById("surface-atlas-file-input");
    const surfaceAtlasFileButton = document.getElementById("surface-atlas-file-button");
    const surfaceAtlasFileSummary = document.getElementById("surface-atlas-file-summary");

    surfaceAtlasFileButton.addEventListener("click", () => {
      surfaceAtlasFileInput.click();
    });

    surfaceAtlasFileInput.addEventListener("change", () => {
      if (surfaceAtlasFileInput.files.length > 0) {
        surfaceAtlasFileSummary.textContent = surfaceAtlasFileInput.files[0].name;
      } else {
        surfaceAtlasFileSummary.textContent = "No file selected";
      }
    });
  </script>
  </div>
</body>
</html>
